<article class="panel">
	<h2>Modelling Software Architecture Using Graphs</h2>
	<section>
		<h3>Part 1 - An Introduction Using GraphViz</h3>
		<p>
			When first approaching a complex ecosystem of software, it is very easy to become overwhelmed.
			As software and it's technical implementation becomes more complex it becomes more difficult to hold the entire
			solution in your mind.
			When systems reach this tipping point it becomes easier for simple mistakes to be made. All it takes is for one link
			or component to be missed and a part of the system can go missing.
		</p>
		<p>
			This series of articles will look at some of the methods and tools that can be used to document and visualise
			architectures. While these are particularly useful for complex systems, they are also fantastic at creating visual
			representations
			of any system, dataflow or architecture.
		</p>
	</section>
	<section>
		<h3>GraphViz</h3>
		<p>
			<a href="https://www.graphviz.org/">GraphViz</a> describes itself as the following:
		</p>
		<blockquote cite="https://www.graphviz.org/">
			Graphviz is open source graph visualization software. Graph visualization is a way of representing structural
			information as diagrams of abstract graphs and networks. It has important applications in networking,
			bio-informatics, software engineering, database and web design, machine learning, and in visual interfaces for other
			technical domains.
		</blockquote>
		<p>
			A graph is a series of vertices or nodes, connected by relationships or edges.
			GraphViz supports many different types of graph, including both directional and non-directional.
			There are also a number of different layout algorithms, that are best suited to different sizes and types of graph.
			In this post we are going to focus on the dot algorithm as it provides a performant solution on large graphs, while
			also giving legible output.
		</p>
	</section>
	<section>
		<h3>GraphViz vs. Microsoft Visio vs. Draw.io</h3>
		<p>
			A tool like GraphViz differs from traditional flowchart and drawing tools.
			The main difference being that with GraphViz you define the objects and relationships as a set of coded rules.
			Additional style rules can be added retrospectively to enhance the generated diagram.
			With tools like <a href="https://draw.io/">Draw.IO</a> or
			<a href="https://products.office.com/en-gb/visio/flowchart-software">Microsoft Visio</a>
			the emphasis is on creating a diagram first.
			This means that you have to juggle the concepts and relationships,
			while also trying to draw and lay these out in a sensible way.
			With GraphViz it is much easier to then refer back to the ruleset that created the diagram. With flowchart tools
			it's easy to corrupt the ruleset by accidently changing the layout.
		</p>
	</section>
	<section>
		<h3>Creating your first graph</h3>
		<p>
			You will need the following software installed:
		</p>
		<ul>
			<li>
				<a href="https://code.visualstudio.com/">Visual Studio Code - Download Here</a>
				<ul>
					<li><a href="https://github.com/Stephanvs/vscode-graphviz">Graphviz (dot) language support for Visual Studio Code</a></li>
					<li><a href="https://marketplace.visualstudio.com/items?itemName=EFanZh.graphviz-preview">GraphViz Preview</a></li>
				</ul>
			</li>
			<li>
				<a href="https://www.graphviz.org/download/">GraphViz - Download Here</a>
			</li>
		</ul>
		<p>
			Both Visual Studio Code and GraphViz can be installed directly from their respective websites. The two dependencies
			in Visual Studio Code can be installed through the marketplace. Although not required they do simplify the process
			of generating graphs.
			When installing GraphViz Preview you will need to change the "graphvizPreview.dotPath" setting in Visual Studio Code
			to point to your GraphViz "dot.exe" file. This allows the preview to generate.
		</p>
		<p>
			To create your first diagram a file needs to be created of the type .dot this is where your rules will go.
			If you are using the recommended toolset you should also be able to open a preview by hitting CTRL+SHIFT+P and
			selecting GraphViz Preview.
		</p>
		<p>
			For our first attempt lets look at a simple web application. The concepts we're dealing with are a user interface,
			our business logic and our data persistance layer. In most cases this will be a simple website with a database back
			end.
			Now we know our core concepts we can add them to our first graph.
		</p>
		<pre><code>
	digraph{

		"User Interface";
		"Business Logic";
		"Data Persistance";
		"Website";
		"Database";
	}
</code></pre>
		<p>
			By adding the above code snippet to your .dot file, you are declaring that there is a digraph, directional graph,
			and that there are 5 nodes. Although we have quoted all of our nodes, this is only required if there is a space in
			the name. The nodes are as follows:
		</p>

		<ul>
			<li>User Interface</li>
			<li>Business Logic</li>
			<li>Data Persistance</li>
			<li>Website</li>
			<li>Database</li>
		</ul>

		<p>
			If we run this through our preview the output we receive is as follows:
		</p>

		<figure>
			<img src="./images/posts/graph-architecture-part-1/web concepts.svg" />
			<figcaption>A graph of website concepts.</figcaption>
		</figure>

		<p>While not the prettiest graph, yet. The speed with which we can add new nodes is very rapid. The benefits are even
			more obvious in the next section where we start linking concepts.</p>
	</section>
	<section>
		<h3>Adding Relationships</h3>
		<p>
			Now we have our core concepts. Let's start linking them together. The code example below how we can change our file
			to achieve this.
		</p>
		<pre><code>
			digraph{
		
				"User Interface" -> "Business Logic";
				"Business Logic" -> "Data Persistance";

				"Website" -> "Database";
			}
		</code></pre>
		<p>
			The code sample above might look a bit different from our previous attempt. With this example we are now declaring
			three relationships. The relationships in a directional graph are represented by
			arrows. These flow from left to right.
		</p>
		<p>
			Again, in the above we can see our concepts declared albeit differently. Any time a word is used either on it's own,
			as in the first example, or as part of a relationship in this example, a new node is created.
			The names given have to be unique or else the assumption is made that all the mentions refer to the same node.
		</p>
		<figure>
			<img src="./images/posts/graph-architecture-part-1/web concepts relationships.svg" />
			<figcaption>A graph of website concepts and their relationships.</figcaption>
		</figure>
	</section>
	<section>
		<h3>Advanced Relationships</h3>
		<p>Now we have the fundamentals worked out, we can take this even further. In our diagram we have two sets of
			concepts, one that is logical and one that is more tangible.
			The relationships have been added for each of these groups, but actually a different set of relationships link the
			two.
		</p>
		<p>
			In a traditional 3 tier web application the website contains the user interface, business logic and data persistance
			layers. The data persistance layer is then responsible for talking to the database. We can represent this with the
			following additional rules:
		</p>
		<pre><code>
			digraph{
		
				"User Interface" -> "Business Logic";
				"Business Logic" -> "Data Persistance";
				"Website" -> "Database";

				"Website" -> "User Interface";
				"Website" -> "Business Logic";
				"Website" -> "Data Persistance";
				"Data Persistance" -> "Database";
			}
		</code></pre>
		<p>Just by adding four extra rules to our existing concepts we can generate the following:</p>
		<figure>
			<img src="./images/posts/graph-architecture-part-1/web concepts relationships adv.svg" />
			<figcaption>A graph of website concepts and their relationships.</figcaption>
		</figure>
		<p>
			However, this is starting to get a little messy with all the relationships. What we could do with doing is grouping
			the different concepts so we can visualise how they are different from each other.
		</p>
		<pre><code>
			digraph{

				subgraph cluster1{
					"User Interface";
					"Business Logic";
					"Data Persistance";
					label = "Logical concepts";
				}
			
				subgraph cluster2{
					"Website";
					"Database";
					label = "Tangible concepts";
				}
			
				"User Interface" -> "Business Logic";
				"Business Logic" -> "Data Persistance";
			
				"Website" -> "Database";
				
				"Website" -> "User Interface";
				"Website" -> "Business Logic";
				"Website" -> "Data Persistance";
				"Data Persistance" -> "Database";
			}
		</code></pre>
		<figure>
			<img src="./images/posts/graph-architecture-part-1/web concepts relationships adv 2.svg" />
			<figcaption>A graph of grouped website concepts and their relationships.</figcaption>
		</figure>
	</section>
	<section>
		<h3>Styling Graphs</h3>
	</section>
	<section>
		<h3>Next Steps</h3>
	</section>

</article>